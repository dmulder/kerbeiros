use super::byteparser;
use md4::{Md4, Digest};


fn md4(bytes: &[u8]) -> Vec<u8> {
    return Md4::digest(&bytes).to_vec();
}

fn string_unicode_bytes(s: &str) -> Vec<u8> {
    let s_utf16: Vec<u16> = s.encode_utf16().collect();
    return byteparser::u16_array_to_le_bytes(&s_utf16);
}

pub fn ntlm_hash(s: &str) -> Vec<u8> {
    let unicode_bytes = string_unicode_bytes(s);
    return md4(&unicode_bytes);
}



#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_ntlm_hash(){
        assert_eq!(vec![0x20, 0x9c, 0x61, 0x74, 0xda, 0x49, 0x0c, 0xae, 0xb4, 0x22, 0xf3, 0xfa, 0x5a, 0x7a, 0xe6, 0x34], 
                   ntlm_hash("admin"));
        assert_eq!(vec![0x0c, 0xb6, 0x94, 0x88, 0x05, 0xf7, 0x97, 0xbf, 0x2a, 0x82, 0x80, 0x79, 0x73, 0xb8, 0x95, 0x37], 
                   ntlm_hash("test"));
        assert_eq!(vec![0x2f, 0xd6, 0xbd, 0xe7, 0xdb, 0x06, 0x81, 0x88, 0x74, 0x98, 0x91, 0x4c, 0xb2, 0xd2, 0x01, 0xef], 
                   ntlm_hash("1337"));
        assert_eq!(vec![0x31, 0xd6, 0xcf, 0xe0, 0xd1, 0x6a, 0xe9, 0x31, 0xb7, 0x3c, 0x59, 0xd7, 0xe0, 0xc0, 0x89, 0xc0], 
                   ntlm_hash(""));
        assert_eq!(vec![0x25, 0x97, 0x45, 0xcb, 0x12, 0x3a, 0x52, 0xaa, 0x2e, 0x69, 0x3a, 0xaa, 0xcc, 0xa2, 0xdb, 0x52], 
                   ntlm_hash("12345678"));
        assert_eq!(vec![0xc2, 0x2b, 0x31, 0x5c, 0x04, 0x0a, 0xe6, 0xe0, 0xef, 0xee, 0x35, 0x18, 0xd8, 0x30, 0x36, 0x2b], 
                   ntlm_hash("123456789"));
    
    }



}
